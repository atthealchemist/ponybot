from abc import ABC as AbstractBase, abstractmethod

from django.utils.translation import gettext as _
from bot.utils import camel_to_snake


import requests


class Action(AbstractBase):
    """
    Base class of bot Action.

    To create new action for your bot, you should inherit from this class.

    Your action should be called 'Action<CapitalCaseActionName>' e.g. ActionPonyProfileInfo

    Params:
        action_id - generated by default
        aliases - strings which can fire your action

    Methods:
        call(self, event) - all logic of your action should be placed here
    """

    def __init__(self, aliases=None):
        self.aliases = aliases

    @abstractmethod
    def call(self, user_id, peer_id, message, user):
        pass

    def __repr__(self):
        return f', '.join(self.aliases)

    def __str__(self):
        return repr(self)


class SimpleAction(Action):

    @property
    def action_id(self):
        return camel_to_snake(self.__class__.__name__)

    def __init__(self, bot):
        # We need to add long_poll as ctor arg cause we're auto loading all actions
        self.bot = bot


class DialogAction(SimpleAction):

    def ask(self, peer_id, user, question, answer_message=None):
        self.bot.say(peer_id, question)
        for user_id, _, message, event in self.bot.listen_new_messages():
            if any(['action' in event.object.message]):
                self.bot.logger.debug("user not equal, exiting...")
                break

            if answer_message:
                self.bot.say(
                    peer_id,
                    answer_message.format(message)
                )
            return message

    def choice(self, peer_id, user, question, choices, answer_message=None):
        answer = ""
        while answer not in choices:
            answer = self.ask(
                peer_id=peer_id,
                user=user,
                question=question + ', '.join(choices),
                answer_message=answer_message
            )
            self.bot.logger.debug(f"Answer: {answer}")
            if answer in choices:
                break
            self.bot.warn(peer_id, _(
                "Такого варианта нет среди предложенных!"))
        return answer

    def __init__(self, bot):
        super().__init__(bot=bot)


class UploadPhotoAction(SimpleAction):

    def __get_attachments(self, event):
        res = []
        attachments = event.object.message.get('attachments')
        for attach in attachments:
            res.extend([
                s for s in attach.get('photo').get('sizes')
                if s.get('type') == 'z'
            ])
        return res

    def ask_photo(self, peer_id, user, question, declines=None):
        self.bot.say(peer_id, question)
        for from_id, peer_id, _, event in self.bot.listen_new_messages():
            if from_id != user.username:
                break

            if any([
                d for d in declines
                if d.lower() in event.object.message.get('text').lower()
            ]):
                break

            # We're getting attachment url from event
            for attachment in self.__get_attachments(event):
                with requests.Session() as session:
                    image = session.get(attachment.get('url'), stream=True)
                    photo_url = self.bot.upload_photo(
                        image.raw,
                        peer_id=peer_id
                    )
                    return photo_url

    def __init__(self, bot):
        super().__init__(bot=bot)
