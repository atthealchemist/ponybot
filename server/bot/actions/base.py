from abc import ABC as AbstractBase, abstractmethod
from bot.models import DialogSession

from django.utils.translation import gettext as _
from bot.utils import camel_to_snake


import requests


class Action(AbstractBase):
    """
    Base class of bot Action.

    To create new action for your bot, you should inherit from this class.

    Your action should be called 'Action<CapitalCaseActionName>' e.g. ActionPonyProfileInfo

    Params:
        action_id - generated by default
        aliases - strings which can fire your action

    Methods:
        call(self, event) - all logic of your action should be placed here
    """

    def __init__(self, aliases=None):
        self.aliases = aliases

    @abstractmethod
    def call(self, session, message, user):
        pass

    def __repr__(self):
        return f', '.join(self.aliases)

    def __str__(self):
        return repr(self)


class SimpleAction(Action):

    @property
    def action_id(self):
        return camel_to_snake(self.__class__.__name__)

    def __init__(self, bot):
        # We need to add long_poll as ctor arg cause we're auto loading all actions
        self.bot = bot


class DialogStep:

    def __str__(self):
        return f"Step (func={self.func_name} param={self.param_name} question={self.attrs.get('question', 'not set')})"

    def __init__(self, func_name="", param_name="", **attrs):
        self.func_name = func_name
        self.param_name = param_name
        self.attrs = attrs

class DialogAction(SimpleAction):

    def ask(self, session, question, answer_message=None):
        self.bot.say(session, question.lower())
        for user_id, peer_id, message, event in self.bot.listen_new_messages():
            if 'action' in event.object.message:
                break

            active_user_session = DialogSession.objects.filter(
                opened=True,
                user_id=user_id,
                peer_id=peer_id
            )
            if not active_user_session.exists():
                continue

            active_user_session = active_user_session.first()
            active_user_session.set_last_message(
                user_id,
                peer_id,
                message
            )
            last_message_user_id = active_user_session.last_message.get(
                'user_id')

            if last_message_user_id != user_id:
                continue

            if answer_message:
                self.bot.say(
                    session,
                    answer_message.format(message)
                )
            return message

    def choice(self, session, question, choices, answer_message=None):
        answer = ""
        while answer not in choices:
            answer = self.ask(
                session,
                question=question + ', '.join(choices),
                answer_message=answer_message
            )
            self.bot.logger.debug(f"Answer: {answer}")
            answer = answer.lower()
            if answer in choices:
                break
            self.bot.warn(session, _(
                "Такого варианта нет среди предложенных!"))
        return answer

    def __init__(self, bot):
        super().__init__(bot=bot)
        self.steps = None


class UploadPhotoAction(SimpleAction):

    def __get_attachments(self, event):
        res = []
        attachments = event.object.message.get('attachments')
        for attach in attachments:
            res.extend([
                s for s in attach.get('photo').get('sizes')
                if s.get('type') == 'z'
            ])
        return res

    def ask_photo(self, session, question, declines=None):
        self.bot.say(session, question)
        for user_id, peer_id, message, event in self.bot.listen_new_messages():
            if not DialogSession.objects.filter(
                opened=True,
                user_id=user_id,
                peer_id=peer_id
            ).exists():
                continue

            if any([
                d for d in declines
                if d.lower() in message.lower()
            ]):
                return "-"

            # We're getting attachment url from event
            for attachment in self.__get_attachments(event):
                with requests.Session() as ws:
                    image = ws.get(attachment.get('url'), stream=True)
                    photo_url = self.bot.upload_photo(
                        image.raw,
                        peer_id=peer_id
                    )
                    return photo_url

    def __init__(self, bot):
        super().__init__(bot=bot)
